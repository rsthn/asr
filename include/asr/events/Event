#ifndef __ASR_EVENTS_EVENT_H
#define __ASR_EVENTS_EVENT_H

#include <memory>
#include <list>

#include <asr/ptr>

namespace asr {
namespace events {

    /**
     * Maximum number of event types (and masks).
     */
    #define ASR_MAX_EVENT_CODES		256
    #define ASR_EVENT_CODE_MASK		0x0000FF
    #define ASR_EVENT_GRP_MASK		0xFFFF00

    /**
     * Converts an eventGroup:eventCode pair to a single 24-bit integer describing an event code.
     */
    #define EVTCODE(grp, code) ((((grp)<<8)&ASR_EVENT_GRP_MASK)|((code)&ASR_EVENT_CODE_MASK))
    #define EVTGRP(grp) (((grp)<<8)&ASR_EVENT_GRP_MASK)

    // Forward declaration.
    class Event;
    class EventBus;

    //
    typedef void (EventHandler) (Event*);

    //
    struct EventListener
    {
        /**
         * Indicates if the listener has been silenced if greater than zero. When so, the handler will not be executed.
         */
        int silent;

        /**
         * Event group (zero is the global group).
         */
        int eventGroup;

        /**
         * Handler function.
         */
        EventHandler *handler;

        /**
         * Constructs the event listener.
         */
        EventListener (int eventGroup, EventHandler *handler) : 
            silent(0), eventGroup(eventGroup), handler(handler)
        { }
    };

    /**
     * Holds the information about a triggered event. It also provides support to allow asynchronous event
     * propagation and event chaining.
     */
    class Event
    {
        friend EventBus;

        private:

        /**
         * Event bus that triggered the event.
         */
        EventBus *bus;

        /**
         * Indicates if the most recent event handler called wants to use async mode. Set by calling the `wait` method.
         */
        bool isAsync;

        /**
         * Queue of listeners to invoke.
         */
        std::list<ptr<EventListener>> list;

        /**
         * Node to the current event listener to execute.
         */
        std::list<ptr<EventListener>>::iterator curr;

        /**
         * Next event to be dispatched when the current event is resolved.
         */
        ptr<Event> next;

        /**
         * Sets the list of listeners to invoke.
         */
        void prepare (EventBus *bus, std::list<ptr<EventListener>> &&list) {
            this->bus = bus;
            this->list = list;
            curr = this->list.begin();
        }

        public:

        /**
         * Code of the event.
         */
        int eventCode;

        /**
         * Time of the event in milliseconds.
         */
        time_t eventTime;

        /**
         */
        Event (int eventCode, int eventGroup=0, time_t eventTime=0)
            : eventCode(EVTCODE(eventGroup, eventCode)), eventTime(eventTime)
        {
            isAsync = false;
            next = nullptr;
        }

        virtual ~Event() = default;
        Event(const Event&) = delete;
        Event& operator=(const Event&) = delete;
        Event(Event&&) noexcept = delete;
        Event& operator=(Event&&) noexcept = delete;

        /**
         * Sets the internal asynchronous flag, should be called before a handler returns. If a handler calls
         * this method it should also call `resume` when all async operations are finished.
         */
        void wait() {
            isAsync = true;
        }

        /**
         * Resumes event propagation. Should be called if an event handler had previously called `wait`.
         */
        void resume();

        /**
         * Adds the specified event to the bottom of this event chain.
         * @param event 
         */
        void enqueue (ptr<Event> event);
    };

}};

#endif
