#ifndef __ASR_EVENTS_EVENTBUS_H
#define __ASR_EVENTS_EVENTBUS_H

#include <memory>
#include <list>

#include <asr/events/Event>
#include <asr/ptr>

namespace asr {
namespace events {

    /**
     * Allocates an event code.
     */
    #define	ALLOCEVTCODE() (EventBus::availableEventCode++)

    /**
     * The event bus class allows several event listeners to be attached to it, these will be invoked
     * whenever the event that is being listened to is triggered.
     */
    class EventBus
    {
        private:

        /**
         * Listeners attached to this event bus. Grouped by event code.
         */
        std::list<ptr<EventListener>> listeners[ASR_MAX_EVENT_CODES];

        /**
         * Queue of delayed events. All delayed events are dispatched by calling dispatch().
         */
        std::list<ptr<Event>> queue;


        public:

        /**
         * Next free event code.
         */
        static int availableEventCode;

        /**
         */
        EventBus() { }
        virtual ~EventBus() { }

        /**
         * Removes all listeners and empties the queue.
         */
        void reset();

        /**
         * Adds an event listener for a specified event.
         * 
         * @param eventGroup 
         * @param eventCode
         * @param handler
         * @return bool
         */
        bool on (int eventGroup, int eventCode, EventHandler *handler);

        bool on (int eventCode, EventHandler *handler) {
            return on(eventCode & ASR_EVENT_GRP_MASK, eventCode, handler);
        }

        /**
         * Removes an event listener from the bus. If only the event code or group is provided all the
         * handlers attached to that event or group will be removed.
         * 
         * @param eventGroup 
         * @param eventCode 
         * @param handler 
         * @return bool 
         */
        bool off (int eventGroup, int eventCode=0, EventHandler *handler=nullptr);

        bool off (int eventCode, EventHandler *handler=nullptr) {
            return off(eventCode & ASR_EVENT_GRP_MASK, eventCode, handler);
        }

        /**
         * Silences or unsilences all handlers attached to an event. If the event fires, silenced handler
         * will not be called.
         * 
         * @param eventGroup 
         * @param eventCode 
         * @param value 
         * @return bool 
         */
        bool silence (int eventGroup, int eventCode, bool value);

        bool silence (int eventCode, bool value) {
            return silence(eventCode & ASR_EVENT_GRP_MASK, eventCode, value);
        }

        /**
         * Prepares an event for its later use. The event is started by calling the `resume` method. Note that
         * `false` is returned if there is an error with the eventCode or if there are no listeners for the event.
         * 
         * @param event 
         * @return bool
         */
        bool prepare (ptr<Event> &event);

        /**
         * Dispatches an event to the respective listeners.
         * @param event 
         */
        void dispatch (ptr<Event> event);

        /**
         * Adds an event to the event bus's queue. Delayed events are dispatched by calling `dispatch`. If there
         * is no matching listener for the desired event no handler will be queued.
         * 
         * @param event 
         */
        void enqueue (ptr<Event> event);

        /**
         * Dispatches all the delayed events added to the event bus.
         */
        void dispatch();

    };

}};

#endif
